use std::fmt;
use std::io;

use crate::disk::block::{BlockDeviceRef, Location};
pub use crate::disk::error::DiskError;
use crate::disk::format::DiskFormat;
use crate::disk::geos::GEOSDiskHeader;
use crate::disk::{self, Id, PADDING_BYTE};
use crate::petscii::Petscii;

/// A HeaderFormat describes how header information is stored for a particular
/// disk image format.
pub struct HeaderFormat {
    pub location: Location,
    // offsets
    pub first_directory_offset: usize,
    pub disk_format_type_offset: usize,
    pub disk_name_offset: usize,
    pub disk_id_offset: usize,
    pub directory_dos_version_offset: usize,
    pub directory_format_type_offset: usize,
    pub padding_offsets: &'static [u8],
    // DOS version and format type defaults
    // See the notes in the cbm::disk module documentation for full details.
    pub default_disk_format_type: u8,
    pub default_directory_dos_version: u8,
    pub default_directory_format_type: u8,
    // expectations
    pub double_sided_flag_expectation: Option<(usize, u8)>,
}

pub struct Header {
    // http://unusedino.de/ec64/technical/formats/d64.html
    // says to not trust this field.
    pub first_directory_sector: Location,
    pub disk_format_type: u8,
    pub disk_name: Petscii,
    pub disk_id: Id,
    pub directory_dos_version: u8,
    pub directory_format_type: u8,
    pub geos: Option<GEOSDiskHeader>,
}

impl Header {
    pub fn new(
        header_format: &HeaderFormat,
        disk_format: &DiskFormat,
        name: &Petscii,
        id: &Id,
    ) -> Header {
        Header {
            first_directory_sector: disk_format.first_directory_location(),
            disk_format_type: header_format.default_disk_format_type,
            disk_name: name.clone(),
            disk_id: *id,
            directory_format_type: header_format.default_directory_format_type,
            directory_dos_version: header_format.default_directory_dos_version,
            geos: None,
        }
    }

    /// Read a header from disk using the provided header format.
    pub fn read(blocks: BlockDeviceRef, format: &HeaderFormat) -> io::Result<Header> {
        let blocks = blocks.borrow();
        let block = blocks.sector(format.location)?;

        // We don't enforce any particular values for these fields when reading or
        // writing disks. See the notes in the cbm::disk module documentation for full
        // details.
        let directory_dos_version = block[format.directory_dos_version_offset];
        let directory_format_type = block[format.directory_format_type_offset];

        // This field is the diskette format type. We don't enforce any particular value
        // for this field. A real CBM DOS would allow the disk to be read normally
        // regardless of the value of this field, but would error if write attempts are
        // made to a disk with a DOS version other than 0x00 or the expected DOS
        // version. See the notes in the cbm::disk module documentation for full
        // details.
        let disk_format_type = block[format.disk_format_type_offset];

        // All 1571 disk images should have the double-side flag set.
        if let Some((offset, value)) = format.double_sided_flag_expectation {
            if block[offset] != value {
                return Err(DiskError::InvalidHeader.into());
            }
        }

        Ok(Header {
            first_directory_sector: Location::from_bytes(&block[format.first_directory_offset..]),
            disk_format_type,
            disk_name: Petscii::from_bytes(
                &block[format.disk_name_offset..format.disk_name_offset + disk::DISK_NAME_SIZE],
            ),
            disk_id: Id::from_bytes(&block[format.disk_id_offset..format.disk_id_offset + 2]),
            directory_dos_version,
            directory_format_type,
            geos: GEOSDiskHeader::new(block),
        })
    }

    /// Write the header to the provided block buffer.  This function only
    /// writes into the regions corresponding to the fields we know about,
    /// thus allowing the preservation of any non-standard fields if the
    /// caller provides the current header block.
    pub fn write(&mut self, blocks: BlockDeviceRef, format: &HeaderFormat) -> io::Result<()> {
        // Read the header block
        let mut block = blocks.borrow().sector(format.location)?.to_vec();

        // Render our header struct into the block
        {
            self.first_directory_sector
                .write_bytes(&mut block[format.first_directory_offset..]);
            block[format.disk_format_type_offset] = self.disk_format_type;
            self.disk_name
                .write_bytes_with_padding(
                    &mut block
                        [format.disk_name_offset..format.disk_name_offset + disk::DISK_NAME_SIZE],
                    PADDING_BYTE,
                )
                .map_err(|_| {
                    let e: io::Error = DiskError::FilenameTooLong.into();
                    e
                })?;
            block[format.disk_id_offset] = self.disk_id[0];
            block[format.disk_id_offset + 1] = self.disk_id[1];
            block[format.directory_dos_version_offset] = self.directory_dos_version;
            block[format.directory_format_type_offset] = self.directory_format_type;
        }

        // All 1571 disk images should have the double-side flag set.
        if let Some((offset, value)) = format.double_sided_flag_expectation {
            block[offset] = value;
        }

        // Headers should have certain bytes set to the padding byte (0xA0).  If this
        // is not done, directory listings generated by CBM DOS will be garbled
        // on the "blocks free" line.
        for padding_offset in format.padding_offsets {
            block[*padding_offset as usize] = disk::PADDING_BYTE;
        }

        // Write the header block
        blocks
            .borrow_mut()
            .sector_mut(format.location)?
            .copy_from_slice(&block);
        Ok(())
    }
}

impl fmt::Debug for Header {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        writeln!(f, "disk name: {:?}", self.disk_name)?;
        writeln!(f, "disk id: {:?}", self.disk_id)?;
        writeln!(
            f,
            "directory dos version and format type: {}",
            Petscii::from_bytes(&[self.directory_dos_version, self.directory_format_type]),
        )?;
        writeln!(
            f,
            "format: {}",
            match self.geos {
                Some(ref geos) => geos.id.to_escaped_string(),
                None => "CBM".to_string(),
            }
        )
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::disk::{Disk, DiskType, D64, D71, D81};

    /// Header block from the 1541 demo disk
    static HEADER_1541_DEMO_DISK_D64: [u8; 256] = [
        0x12, 0x01, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0xff, 0xff, 0x1f, 0x15, 0xff, 0xff, 0x1f, 0x15, 0xff,
        0xff, 0x1f, 0x15, 0xff, 0xff, 0x1f, 0x15, 0xff, 0xff, 0x1f, 0x15, 0xff, 0xff, 0x1f, 0x07,
        0x30, 0xe2, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x6c, 0xfb,
        0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0xf0, 0xe3, 0x03, 0x12,
        0xff, 0xff, 0x03, 0x12, 0xff, 0xff, 0x03, 0x12, 0xff, 0xff, 0x03, 0x12, 0xff, 0xff, 0x03,
        0x12, 0xff, 0xff, 0x03, 0x11, 0xff, 0xff, 0x01, 0x11, 0xff, 0xff, 0x01, 0x11, 0xff, 0xff,
        0x01, 0x11, 0xff, 0xff, 0x01, 0x11, 0xff, 0xff, 0x01, 0x54, 0x45, 0x53, 0x54, 0x2f, 0x44,
        0x45, 0x4d, 0x4f, 0x20, 0x20, 0x31, 0x2f, 0x38, 0x35, 0xa0, 0xa0, 0xa0, 0x38, 0x34, 0xa0,
        0x32, 0x41, 0xa0, 0xa0, 0xa0, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00,
    ];

    /// Header block from a GEOS 2.0 boot disk (1541)
    static HEADER_GEOS_V20_BOOT_D64: [u8; 256] = [
        0x12, 0x01, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0xbc, 0xbd,
        0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xef, 0xbf,
        0x01, 0x11, 0xff, 0xff, 0x01, 0x11, 0xff, 0xff, 0x01, 0x47, 0x45, 0x4f, 0x53, 0x20, 0x36,
        0x34, 0x20, 0x76, 0x32, 0x2e, 0x30, 0x20, 0x41, 0x4d, 0xa0, 0xa0, 0xa0, 0x30, 0x30, 0xa0,
        0x32, 0x41, 0xa0, 0xa0, 0xa0, 0xa0, 0x13, 0x08, 0x47, 0x45, 0x4f, 0x53, 0x20, 0x66, 0x6f,
        0x72, 0x6d, 0x61, 0x74, 0x20, 0x56, 0x31, 0x2e, 0x30, 0x4b, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00,
    ];

    /// Header block from a freshly formatted 1571 image
    static HEADER_EMPTY_D71: [u8; 256] = [
        0x12, 0x01, 0x41, 0x80, 0x15, 0xff, 0xff, 0x1f, 0x15, 0xff, 0xff, 0x1f, 0x15, 0xff, 0xff,
        0x1f, 0x15, 0xff, 0xff, 0x1f, 0x15, 0xff, 0xff, 0x1f, 0x15, 0xff, 0xff, 0x1f, 0x15, 0xff,
        0xff, 0x1f, 0x15, 0xff, 0xff, 0x1f, 0x15, 0xff, 0xff, 0x1f, 0x15, 0xff, 0xff, 0x1f, 0x15,
        0xff, 0xff, 0x1f, 0x15, 0xff, 0xff, 0x1f, 0x15, 0xff, 0xff, 0x1f, 0x15, 0xff, 0xff, 0x1f,
        0x15, 0xff, 0xff, 0x1f, 0x15, 0xff, 0xff, 0x1f, 0x15, 0xff, 0xff, 0x1f, 0x11, 0xfc, 0xff,
        0x07, 0x13, 0xff, 0xff, 0x07, 0x13, 0xff, 0xff, 0x07, 0x13, 0xff, 0xff, 0x07, 0x13, 0xff,
        0xff, 0x07, 0x13, 0xff, 0xff, 0x07, 0x13, 0xff, 0xff, 0x07, 0x12, 0xff, 0xff, 0x03, 0x12,
        0xff, 0xff, 0x03, 0x12, 0xff, 0xff, 0x03, 0x12, 0xff, 0xff, 0x03, 0x12, 0xff, 0xff, 0x03,
        0x12, 0xff, 0xff, 0x03, 0x11, 0xff, 0xff, 0x01, 0x11, 0xff, 0xff, 0x01, 0x11, 0xff, 0xff,
        0x01, 0x11, 0xff, 0xff, 0x01, 0x11, 0xff, 0xff, 0x01, 0x31, 0x35, 0x37, 0x31, 0x20, 0x42,
        0x4c, 0x41, 0x4e, 0x4b, 0x20, 0x44, 0x49, 0x53, 0x4b, 0xa0, 0xa0, 0xa0, 0x38, 0x39, 0xa0,
        0x32, 0x41, 0xa0, 0xa0, 0xa0, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x15, 0x15, 0x15,
        0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x00, 0x13,
        0x13, 0x13, 0x13, 0x13, 0x13, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x11, 0x11, 0x11, 0x11,
        0x11,
    ];

    /// Header block from a freshly formatted 1571 image in GEOS 128
    static HEADER_GEOS_EMPTY_D71: [u8; 256] = [
        0x12, 0x01, 0x41, 0x80, 0x15, 0xff, 0xff, 0x1f, 0x15, 0xff, 0xff, 0x1f, 0x15, 0xff, 0xff,
        0x1f, 0x15, 0xff, 0xff, 0x1f, 0x15, 0xff, 0xff, 0x1f, 0x15, 0xff, 0xff, 0x1f, 0x15, 0xff,
        0xff, 0x1f, 0x15, 0xff, 0xff, 0x1f, 0x15, 0xff, 0xff, 0x1f, 0x15, 0xff, 0xff, 0x1f, 0x15,
        0xff, 0xff, 0x1f, 0x15, 0xff, 0xff, 0x1f, 0x15, 0xff, 0xff, 0x1f, 0x15, 0xff, 0xff, 0x1f,
        0x15, 0xff, 0xff, 0x1f, 0x15, 0xff, 0xff, 0x1f, 0x15, 0xff, 0xff, 0x1f, 0x11, 0xfc, 0xff,
        0x07, 0x12, 0xbf, 0xff, 0x07, 0x13, 0xff, 0xff, 0x07, 0x13, 0xff, 0xff, 0x07, 0x13, 0xff,
        0xff, 0x07, 0x13, 0xff, 0xff, 0x07, 0x13, 0xff, 0xff, 0x07, 0x12, 0xff, 0xff, 0x03, 0x12,
        0xff, 0xff, 0x03, 0x12, 0xff, 0xff, 0x03, 0x12, 0xff, 0xff, 0x03, 0x12, 0xff, 0xff, 0x03,
        0x12, 0xff, 0xff, 0x03, 0x11, 0xff, 0xff, 0x01, 0x11, 0xff, 0xff, 0x01, 0x11, 0xff, 0xff,
        0x01, 0x11, 0xff, 0xff, 0x01, 0x11, 0xff, 0xff, 0x01, 0x31, 0x35, 0x37, 0x31, 0x20, 0x47,
        0x45, 0x4f, 0x53, 0x20, 0x44, 0x69, 0x73, 0x6b, 0xa0, 0xa0, 0xa0, 0xa0, 0x43, 0x42, 0xa0,
        0x32, 0x41, 0xa0, 0xa0, 0xa0, 0xa0, 0x13, 0x06, 0x47, 0x45, 0x4f, 0x53, 0x20, 0x66, 0x6f,
        0x72, 0x6d, 0x61, 0x74, 0x20, 0x56, 0x31, 0x2e, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x15, 0x15, 0x15,
        0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x00, 0x13,
        0x13, 0x13, 0x13, 0x13, 0x13, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x11, 0x11, 0x11, 0x11,
        0x11,
    ];

    /// Header block from the 1581 demo disk
    static HEADER_1581_DEMO_DISK_D81: [u8; 256] = [
        0x28, 0x03, 0x44, 0x00, 0x31, 0x35, 0x38, 0x31, 0x20, 0x55, 0x54, 0x49, 0x4c, 0x49, 0x54,
        0x59, 0x20, 0x56, 0x30, 0x32, 0xa0, 0xa0, 0x47, 0x42, 0xa0, 0x33, 0x44, 0xa0, 0xa0, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00,
    ];

    /// Header block from a 1581 GEOS boot image
    static HEADER_GEOS_BOOT_D81: [u8; 256] = [
        0x28, 0x03, 0x44, 0x00, 0x47, 0x45, 0x4f, 0x53, 0x20, 0x36, 0x34, 0xa0, 0xa0, 0xa0, 0xa0,
        0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0x30, 0x31, 0xa0, 0x33, 0x44, 0xa0, 0xa0, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x13, 0x47, 0x45, 0x4f, 0x53, 0x20, 0x66, 0x6f,
        0x72, 0x6d, 0x61, 0x74, 0x20, 0x56, 0x31, 0x2e, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00,
    ];

    /// Header block from a C65 formatted empty disk
    static HEADER_C65_EMPTY_D81: [u8; 256] = [
        0x28, 0x03, 0x44, 0x00, 0x4d, 0x59, 0x44, 0x49, 0x53, 0x4b, 0x4e, 0x41, 0x4d, 0x45, 0xa0,
        0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0x30, 0x31, 0xa0, 0x31, 0x44, 0xa0, 0xa0, 0x00,
        0x00, 0x00, 0x01, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00,
    ];

    /// Header block from MEGA65 disk "Zappy!" -- Zappy_CdAhgr.d81
    /// https://files.mega65.org/html/main.php?id=9d1e7e80-e0b1-40ad-a6c2-722451d6afc8
    static HEADER_MEGA65_ZAPPY_D81: [u8; 256] = [
        0x28, 0x03, 0x44, 0x00, 0x5a, 0x41, 0x50, 0x50, 0x59, 0x21, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0,
        0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0x32, 0x30, 0x32, 0x32, 0xa0, 0xa0, 0xa0, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00,
    ];

    /// Header block from MEGA65 disk "megano65" -- megano65_2JbF7a.d81
    /// https://files.mega65.org/html/main.php?id=9d1e7e80-e0b1-40ad-a6c2-722451d6afc8
    static HEADER_MEGA65_MEGANO65_D81: [u8; 256] = [
        0x28, 0x03, 0x44, 0x00, 0x4d, 0x45, 0x47, 0x41, 0x4e, 0x4f, 0x36, 0x35, 0xa0, 0xa0, 0xa0,
        0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0x20, 0x32, 0x30, 0x32, 0x32, 0xa0, 0xa0, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00,
    ];

    /// Header block from MEGA65 disk "Chararacter Editor - Char Eddie V1" -- CEV1_4rXpHp.D81
    /// https://files.mega65.org/html/main.php?id=39993b5a-2816-437f-981c-a02aac8df49e
    static HEADER_MEGA65_CEV1_D81: [u8; 256] = [
        0x28, 0x03, 0x00, 0x00, 0x43, 0x45, 0x56, 0x31, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0,
        0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0x00, 0x00, 0x43, 0x37, 0x00, 0x31, 0x44, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00,
    ];

    /// Header block from MEGA65 disk "Mega Pixel Bomber Blitz" -- pixelblitz_vUSa4k.d81
    /// https://files.mega65.org/html/main.php?id=9a6c653c-93de-41c0-b890-0ce56c39fde2
    static HEADER_MEGA65_PIXELBLITZ_D81: [u8; 256] = [
        0x28, 0x03, 0x44, 0x00, 0x50, 0x49, 0x58, 0x45, 0x4c, 0x20, 0x42, 0x4c, 0x49, 0x54, 0x5a,
        0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0x32, 0x30, 0x32, 0x32, 0xa0, 0xa0, 0xa0, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00,
    ];

    /// Parse the provided header block according to the header format used by the
    /// provided disk type. Panic on error.
    fn parse_header(disk_type: DiskType, header_block: &[u8]) -> Header {
        let mut disk: Box<dyn Disk> = match disk_type {
            DiskType::D64 => Box::new(D64::open_memory(D64::geometry(false)).unwrap()),
            DiskType::D71 => Box::new(D71::open_memory(D71::geometry(false)).unwrap()),
            DiskType::D81 => Box::new(D81::open_memory(D81::geometry(false)).unwrap()),
        };
        let header_format = &disk.native_disk_format().header;
        disk.write_sector(header_format.location, header_block)
            .unwrap();
        Header::read(disk.blocks(), header_format).unwrap()
    }

    #[test]
    fn test_headers() {
        let header = parse_header(DiskType::D64, &HEADER_1541_DEMO_DISK_D64);
        assert_eq!(header.first_directory_sector, Location(18, 1));
        assert_eq!(header.disk_format_type, b'A');
        assert_eq!(header.disk_name.to_string(), "test/demo  1/85\u{a0}");
        assert_eq!(header.disk_id, Id([b'8', b'4']));
        assert_eq!(header.directory_dos_version, b'2');
        assert_eq!(header.directory_format_type, b'A');
        assert!(header.geos.is_none());

        let header = parse_header(DiskType::D64, &HEADER_GEOS_V20_BOOT_D64);
        assert_eq!(header.first_directory_sector, Location(18, 1));
        assert_eq!(header.disk_format_type, b'A');
        assert_eq!(header.disk_name.to_string(), "geos 64 V2.0 am\u{a0}");
        assert_eq!(header.disk_id, Id([b'0', b'0']));
        assert_eq!(header.directory_dos_version, b'2');
        assert_eq!(header.directory_format_type, b'A');
        assert!(header.geos.is_some());
        let geos_header = header.geos.unwrap();
        assert_eq!(geos_header.border, Location(19, 8));
        assert_eq!(geos_header.id.to_escaped_string(), "GEOS format V1.0");

        let header = parse_header(DiskType::D71, &HEADER_EMPTY_D71);
        assert_eq!(header.first_directory_sector, Location(18, 1));
        assert_eq!(header.disk_format_type, b'A');
        assert_eq!(header.disk_name.to_string(), "1571 blank disk\u{a0}");
        assert_eq!(header.disk_id, Id([b'8', b'9']));
        assert_eq!(header.directory_dos_version, b'2');
        assert_eq!(header.directory_format_type, b'A');
        assert!(header.geos.is_none());

        let header = parse_header(DiskType::D71, &HEADER_GEOS_EMPTY_D71);
        assert_eq!(header.first_directory_sector, Location(18, 1));
        assert_eq!(header.disk_format_type, b'A');
        assert_eq!(header.disk_name.to_string(), "1571 geos dISK\u{a0}\u{a0}");
        assert_eq!(header.disk_id, Id([b'C', b'B']));
        assert_eq!(header.directory_dos_version, b'2');
        assert_eq!(header.directory_format_type, b'A');
        assert!(header.geos.is_some());
        let geos_header = header.geos.unwrap();
        assert_eq!(geos_header.border, Location(19, 6));
        assert_eq!(geos_header.id.to_escaped_string(), "GEOS format V1.0");

        let header = parse_header(DiskType::D81, &HEADER_1581_DEMO_DISK_D81);
        assert_eq!(header.first_directory_sector, Location(40, 3));
        assert_eq!(header.disk_format_type, b'D');
        assert_eq!(header.disk_name.to_string(), "1581 utility v02");
        assert_eq!(header.disk_id, Id([b'G', b'B']));
        assert_eq!(header.directory_dos_version, b'3');
        assert_eq!(header.directory_format_type, b'D');
        assert!(header.geos.is_none());

        let header = parse_header(DiskType::D81, &HEADER_GEOS_BOOT_D81);
        assert_eq!(header.first_directory_sector, Location(40, 3));
        assert_eq!(header.disk_format_type, b'D');
        assert_eq!(
            header.disk_name.to_string(),
            "geos 64\u{a0}\u{a0}\u{a0}\u{a0}\u{a0}\u{a0}\u{a0}\u{a0}\u{a0}"
        );
        assert_eq!(header.disk_id, Id([b'0', b'1']));
        assert_eq!(header.directory_dos_version, b'3');
        assert_eq!(header.directory_format_type, b'D');
        assert!(header.geos.is_some());
        let geos_header = header.geos.unwrap();
        assert_eq!(geos_header.border, Location(40, 19));
        assert_eq!(geos_header.id.to_escaped_string(), "GEOS format V1.0");

        let header = parse_header(DiskType::D81, &HEADER_C65_EMPTY_D81);
        assert_eq!(header.first_directory_sector, Location(40, 3));
        assert_eq!(header.disk_format_type, b'D');
        assert_eq!(
            header.disk_name.to_string(),
            "mydiskname\u{a0}\u{a0}\u{a0}\u{a0}\u{a0}\u{a0}"
        );
        assert_eq!(header.disk_id, Id([b'0', b'1']));
        assert_eq!(header.directory_dos_version, b'1');
        assert_eq!(header.directory_format_type, b'D');
        assert!(header.geos.is_none());

        let header = parse_header(DiskType::D81, &HEADER_MEGA65_ZAPPY_D81);
        assert_eq!(header.first_directory_sector, Location(40, 3));
        assert_eq!(header.disk_format_type, b'D');
        assert_eq!(
            header.disk_name.to_string(),
            "zappy!\u{a0}\u{a0}\u{a0}\u{a0}\u{a0}\u{a0}\u{a0}\u{a0}\u{a0}\u{a0}"
        );
        // The Zappy image includes "2022\xA0\xA0\xA0" at header offset 0x16 to cleverly
        // include the year of publication in directory listings. This results in the
        // following odd interpretation of the disk id, DOS version, and format type.
        assert_eq!(header.disk_id, Id([b'2', b'0']));
        assert_eq!(header.directory_dos_version, b'2');
        assert_eq!(header.directory_format_type, 0xA0);
        assert!(header.geos.is_none());

        let header = parse_header(DiskType::D81, &HEADER_MEGA65_MEGANO65_D81);
        assert_eq!(header.first_directory_sector, Location(40, 3));
        assert_eq!(header.disk_format_type, b'D');
        assert_eq!(
            header.disk_name.to_string(),
            "megano65\u{a0}\u{a0}\u{a0}\u{a0}\u{a0}\u{a0}\u{a0}\u{a0}"
        );
        // The megano65 image includes " 2022\xA0\xA0" at header offset 0x16 to cleverly
        // include the year of publication in directory listings. This results in the
        // following odd interpretation of the disk id, DOS version, and format type.
        assert_eq!(header.disk_id, Id([b' ', b'2']));
        assert_eq!(header.directory_dos_version, b'2');
        assert_eq!(header.directory_format_type, b'2');
        assert!(header.geos.is_none());

        let header = parse_header(DiskType::D81, &HEADER_MEGA65_CEV1_D81);
        assert_eq!(header.first_directory_sector, Location(40, 3));
        // The CEV1 image uses 0x00 as the diskette format type, which isn't typical,
        // but (in addition to the expected diskette format type) is valid in CBM DOS
        // for all read and write operations.
        assert_eq!(header.disk_format_type, 0x00);
        assert_eq!(
            header.disk_name.to_string(),
            "cev1\u{a0}\u{a0}\u{a0}\u{a0}\u{a0}\u{a0}\u{a0}\u{a0}\u{a0}\u{a0}\u{a0}\u{a0}"
        );
        assert_eq!(header.disk_id, Id([b'C', b'7']));
        assert_eq!(header.directory_dos_version, b'1');
        assert_eq!(header.directory_format_type, b'D');
        assert!(header.geos.is_none());

        let header = parse_header(DiskType::D81, &HEADER_MEGA65_PIXELBLITZ_D81);
        assert_eq!(header.first_directory_sector, Location(40, 3));
        assert_eq!(header.disk_format_type, b'D');
        assert_eq!(
            header.disk_name.to_string(),
            "pixel blitz\u{a0}\u{a0}\u{a0}\u{a0}\u{a0}"
        );
        // The pixelblitz image includes "2022\xA0\xA0\xA0" at header offset 0x16 to
        // cleverly include the year of publication in directory listings. This results
        // in the following odd interpretation of the disk id, DOS version, and format
        // type.
        assert_eq!(header.disk_id, Id([b'2', b'0']));
        assert_eq!(header.directory_dos_version, b'2');
        assert_eq!(header.directory_format_type, 0xA0);
        assert!(header.geos.is_none());
    }
}
